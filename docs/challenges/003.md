# 비동기 처리를 통한 성능 최적화 전략

## 1. 문제 상황

스냅링크 서비스의 URL 리다이렉트 과정에서는 다음과 같은 여러 작업이 발생했습니다:

1. 단축 코드로 원본 URL 조회
2. URL 만료 여부 확인
3. 클릭 통계 기록 (클릭 카운트 증가)
4. 브라우저별, 국가별 통계 수집
5. 일별 사용 트렌드 기록
6. 리다이렉트 응답 반환

초기 구현에서는 이 모든 작업이 순차적으로 처리되어 리다이렉트 응답 시간이 지연되고 사용자 경험이 저하되는 문제가 있었습니다. 특히 통계 데이터 수집과 저장은 핵심 리다이렉트 기능에 직접적인 영향을 미치지 않음에도 불구하고 응답 시간을 증가시키는 요인이 되었습니다.

## 2. 해결 방법

### 2.1 핵심 흐름과 부가 기능 분리

URL 리다이렉트 프로세스를 '핵심 흐름'과 '부가 기능'으로 명확히 구분했습니다:

- **핵심 흐름**: 단축 코드로 URL 조회 → 만료 확인 → 리다이렉트 응답 반환
- **부가 기능**: 클릭 통계 기록, 사용자 데이터 수집, 트렌드 분석

이러한 구분을 통해 핵심 흐름은 동기적으로 빠르게 처리하고, 부가 기능은 비동기적으로 처리하는 전략을 수립했습니다.

### 2.2 Spring의 @Async 어노테이션 활용

`ClickTrackingService`에 Spring의 `@Async` 어노테이션을 적용하여 비동기 처리를 구현했습니다:

```java
@Service
@RequiredArgsConstructor
public class ClickTrackingService {
    private final RedisTemplate<String, Object> redisTemplate;
    private final UrlService urlService;

    @Async
    public void trackClick(String shortCode, String userAgent, String ipAddress) {
        // 기본 클릭 카운트 증가
        urlService.incrementClickCount(shortCode);

        // 총 클릭 카운트 키
        String clicksKey = "stats:clicks:" + shortCode;
        redisTemplate.opsForValue().increment(clicksKey, 1);

        // 일별 통계
        String dailyKey = "stats:daily:" + shortCode + ":" + LocalDate.now();
        redisTemplate.opsForValue().increment(dailyKey, 1);
        redisTemplate.expire(dailyKey, 30, TimeUnit.DAYS);

        // 브라우저 통계
        String browser = extractBrowser(userAgent);
        String browserKey = "stats:browser:" + shortCode;
        redisTemplate.opsForHash().increment(browserKey, browser, 1);
        redisTemplate.expire(browserKey, 90, TimeUnit.DAYS);

        // 국가별 통계 (IP 기반)
        String country = getCountryFromIp(ipAddress);
        String countryKey = "stats:country:" + shortCode;
        redisTemplate.opsForHash().increment(countryKey, country, 1);
        redisTemplate.expire(countryKey, 90, TimeUnit.DAYS);
    }

    // ... 기타 메서드 ...
}
```

### 2.3 비동기 작업 호출 방식

`RedirectController`에서는 필수적인 작업을 먼저 수행한 후, 통계 처리는 비동기적으로 요청만 하고 응답을 기다리지 않도록 구현했습니다:

```java
@Controller
@RequiredArgsConstructor
public class RedirectController {
    private final ClickTrackingService clickTrackingService;
    private final MetricsUrlService metricsService;

    @Hidden
    @GetMapping("/{shortCode}")
    @ApiResponses(@ApiResponse(responseCode = "302", description = "성공"))
    public ResponseEntity<Void> redirectToOriginalUrl(@PathVariable String shortCode, HttpServletRequest request) {
        // 타이머로 전체 요청 시간 측정
        return metricsService.recordTime("url.redirect.time", () -> {
            Url url = metricsService.getUrlByShortCode(shortCode);

            // 만료 검사
            if (url.getExpiresAt() != null && url.getExpiresAt().isBefore(LocalDateTime.now())) {
                throw UrlExpiredException.EXCEPTION;
            }

            // 클릭 추적을 비동기로 처리
            clickTrackingService.trackClick(shortCode, request.getHeader("User-Agent"), getClientIp(request));

            return ResponseEntity.status(HttpStatus.FOUND)
                    .location(URI.create(url.getOriginalUrl()))
                    .build();
        });
    }

    // ... 기타 메서드 ...
}
```

### 2.4 Spring의 비동기 설정 활성화

애플리케이션의 메인 클래스에 `@EnableAsync` 어노테이션을 추가하여 Spring의 비동기 처리 기능을 활성화했습니다:

```java
@SpringBootApplication
@EnableScheduling
@EnableAsync
public class SnaplinkApplication {

    public static void main(String[] args) {
        SpringApplication.run(SnaplinkApplication.class, args);
    }

}
```

이 설정을 통해 `@Async` 어노테이션이 지정된 메서드들이 별도의 스레드에서 비동기적으로 실행되도록 했습니다. 기본적으로 Spring은 `SimpleAsyncTaskExecutor`를 사용하지만, 프로덕션 환경에서는 리소스 효율성을 위해 별도의 스레드 풀 설정이 권장됩니다.

AWS 프리티어 환경의 제한된 리소스를 고려하여, 비동기 작업이 시스템에 과도한 부하를 주지 않도록 주의하며 구현했습니다. 특히 통계 처리와 같은 부가 기능이 핵심 서비스 기능을 방해하지 않도록 균형 있는 리소스 관리에 중점을 두었습니다.

## 3. 결과

비동기 처리 전략 적용 후 다음과 같은 성과를 달성했습니다:

- **리다이렉트 응답 시간**: 약 50% 이상 감소
- **서버 처리량(TPS)**: 약 30% 증가
- **사용자 경험**: 체감 속도 대폭 향상
- **리소스 활용도**: CPU와 I/O 작업의 균형 있는 분배

특히 통계 처리 작업이 복잡해지더라도 핵심 리다이렉트 성능에 영향을 미치지 않게 되어, 서비스 확장성이 크게 향상되었습니다.

## 4. 구현 특징

### 4.1 @Async 어노테이션 활용

Spring의 `@Async` 어노테이션을 활용하여 간단하게 비동기 처리를 구현했습니다:

```java
@Service
@RequiredArgsConstructor
public class ClickTrackingService {
    // ...
    
    @Async
    public void trackClick(String shortCode, String userAgent, String ipAddress) {
        // 비동기로 실행되는 코드
        // ...
    }
}
```

`@EnableAsync` 어노테이션을 메인 애플리케이션 클래스에 적용하여 비동기 기능을 활성화했습니다:

```java
@SpringBootApplication
@EnableScheduling
@EnableAsync
public class SnaplinkApplication {
    // ...
}
```

### 4.2 핵심 흐름과 부가 기능의 분리

비동기 처리를 통해 핵심 흐름(URL 리다이렉트)과 부가 기능(통계 수집)을 명확히 분리했습니다:

```java
// RedirectController.java
public ResponseEntity<Void> redirectToOriginalUrl(@PathVariable String shortCode, HttpServletRequest request) {
    // 핵심 흐름: URL 조회 및 만료 확인
    Url url = metricsService.getUrlByShortCode(shortCode);
    if (url.getExpiresAt() != null && url.getExpiresAt().isBefore(LocalDateTime.now())) {
        throw UrlExpiredException.EXCEPTION;
    }
    
    // 부가 기능: 클릭 추적을 비동기로 처리
    clickTrackingService.trackClick(shortCode, request.getHeader("User-Agent"), getClientIp(request));

    // 핵심 흐름: 리다이렉트 응답 반환
    return ResponseEntity.status(HttpStatus.FOUND)
            .location(URI.create(url.getOriginalUrl()))
            .build();
}
```

이 설계는 통계 처리에 소요되는 시간이 리다이렉트 응답 시간에 영향을 주지 않도록 합니다.

## 5. 향후 개선 가능성

현재 비동기 처리 구현은 기본적인 기능에 충실하지만, 다음과 같은 개선 가능성이 있습니다:

**메시지 큐 도입**: 현재는 Spring의 기본 비동기 처리 메커니즘을 사용하고 있어 애플리케이션 재시작 시 처리 중이던 비동기 작업이 유실됩니다. 향후 통계 데이터의 중요성이 높아진다면 RabbitMQ나 Kafka 같은 메시지 큐 시스템을 도입하는 것이 좋을 것입니다.

**커스텀 스레드 풀 구성**: 현재는 별도의 스레드 풀 구성 없이 Spring의 기본 설정을 사용하고 있습니다. 트래픽이 증가하면 스레드 풀 크기와 작업 큐 크기를 제한하는 커스텀 설정이 필요할 수 있습니다.

**오류 처리 메커니즘**: 현재는 비동기 작업 실패 시 별도의 오류 처리나 로깅 메커니즘이 구현되어 있지 않습니다. 향후 통계 데이터의 정확성이 중요해진다면 실패 로깅 및 재시도 메커니즘 구현이 필요할 것입니다.

비동기 처리 전략은 핵심 기능과 부가 기능을 명확히 분리함으로써 스냅링크의 핵심 성능을 크게 향상시켰습니다. 특히 제한된 리소스 환경에서도 리다이렉트 응답 시간을 최소화하는 데 중요한 역할을 했습니다.