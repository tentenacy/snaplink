# 데이터베이스 최적화 전략

## 1. 문제 상황

스냅링크 서비스 초기 개발 단계에서는 다음과 같은 데이터베이스 관련 성능 이슈가 존재했습니다:

- 단축 URL 조회 시 46ms의 높은 응답 시간 발생
- 데이터베이스에 과도한 부하 집중 (100% 수준)
- 동시 접속자 증가 시 커넥션 부족 현상
- URL 통계 조회 시 응답 지연 발생

특히 서비스의 핵심 기능인 단축 URL 리다이렉트는 초당 수백 건 이상 발생하는 고부하 작업이기 때문에, 데이터베이스 성능 최적화가 전체 시스템 성능에 직접적인 영향을 미쳤습니다.

## 2. 해결 방법

### 2.1 인덱스 설계 최적화

단축 URL 서비스의 핵심 쿼리 패턴을 분석하여 최적의 인덱스 구조를 설계했습니다.

**Url 엔티티의 인덱스 설계:**

```java
@Entity
@Table(name = "urls", indexes = {
        @Index(name = "idx_url_short_code_expires", columnList = "shortCode, expiresAt"),
        @Index(name = "idx_url_expires_at", columnList = "expiresAt"),
        @Index(name = "idx_url_click_count", columnList = "clickCount")
})
public class Url {
    // ...

    @Column(nullable = false, unique = true, length = 7)
    private String shortCode;

    // ...
}
```

**주요 인덱스 전략:**

1. **복합 인덱스 (shortCode, expiresAt)**:
    - 가장 빈번한 쿼리인 "단축 코드로 유효한 URL 찾기"를 최적화
    - 이 인덱스는 `findActiveByShortCode` 메서드에서 활용됨

   ```java
   @Query("SELECT u FROM Url u WHERE u.shortCode = :shortCode AND (u.expiresAt IS NULL OR u.expiresAt > CURRENT_TIMESTAMP)")
   Optional<Url> findActiveByShortCode(@Param("shortCode") String shortCode);
   ```

2. **만료일 인덱스 (expiresAt)**:
    - 만료된 URL 조회 및 캐시 정리에 활용
    - `findByExpiresAtBefore` 메서드의 성능 개선

   ```java
   List<Url> findByExpiresAtBefore(LocalDateTime now);
   ```

3. **클릭 수 인덱스 (clickCount)**:
    - 인기 URL 검색 및 캐시 워밍업에 활용
    - `findTopUrlsByClickCount` 메서드에서 사용됨

   ```java
   @Query(value = "SELECT * FROM urls u WHERE u.click_count > :minClicks ORDER BY u.click_count DESC LIMIT 100", nativeQuery = true)
   List<Url> findTopUrlsByClickCount(@Param("minClicks") long minClicks);
   ```

4. **Unique 제약조건 (shortCode)**:
    - `shortCode` 필드에 unique 제약조건을 적용하여 중복 방지
    - 이는 내부적으로 유니크 인덱스로 구현되어 조회 성능도 향상

이러한 인덱스 최적화를 통해 URL 조회 시간이 대폭 감소하고, 특히 서비스 확장에 따른 데이터 증가에도 안정적인 성능을 유지할 수 있게 되었습니다.

### 2.2 HikariCP 커넥션 풀 튜닝

AWS 프리티어 환경(t2.micro)에서도 최적의 성능을 발휘할 수 있도록 HikariCP 커넥션 풀 설정을 세밀하게 조정했습니다:

```yaml
spring:
  datasource:
    hikari:
      # HikariCP 튜닝 전
      # maximum-pool-size: 10
      # connection-timeout: 30000
      
      # HikariCP 튜닝 후
      maximum-pool-size: 20              # 동시 연결 수 증가
      minimum-idle: 5                    # 최소 유지 연결 수
      idle-timeout: 300000               # 유휴 연결 제거 시간 (5분)
      max-lifetime: 1800000              # 최대 수명 (30분)
      connection-timeout: 20000          # 연결 타임아웃 (20초)
      connection-test-query: SELECT 1    # 연결 유효성 검사 쿼리
      pool-name: SnapLinkHikariPool      # 커넥션 풀 이름 (모니터링용)
```

**주요 최적화 포인트:**

1. **최대 풀 크기 증가 (10 → 20)**:
    - 동시 요청 처리 능력 향상
    - 읽기 작업 위주의 워크로드에 맞춰 최적화

2. **최소 유지 연결 수 설정 (5)**:
    - 항상 5개의 연결을 준비 상태로 유지
    - 갑작스러운 트래픽 증가에도 즉시 응답 가능

3. **연결 타임아웃 감소 (30초 → 20초)**:
    - 연결 획득 실패 시 더 빠른 오류 감지
    - 클라이언트 응답 대기 시간 단축

4. **연결 유효성 검사 쿼리 설정**:
    - 경량 쿼리(`SELECT 1`)로 연결 유효성 확인
    - 불필요한 재연결 최소화

이러한 튜닝으로 제한된 리소스 환경에서도 효율적인 커넥션 관리가 가능해졌고, 특히 트래픽 급증 시에도 안정적인 서비스 제공이 가능해졌습니다.

### 2.3 쿼리 최적화 및 Prepared Statement 활용

빈번하게 실행되는 쿼리를 최적화하고 Prepared Statement를 활용하여 SQL 파싱 오버헤드를 제거했습니다.

**쿼리 최적화 예시:**

1. **클릭 카운트 증가 쿼리**:
    - 엔티티 전체를 로드하지 않고 직접 업데이트하는 방식으로 최적화

   ```java
   @Modifying
   @Query("UPDATE Url u SET u.clickCount = u.clickCount + 1 WHERE u.shortCode = :shortCode")
   void incrementClickCount(@Param("shortCode") String shortCode);
   ```

2. **인기 URL 조회 쿼리**:
    - 네이티브 쿼리와 LIMIT 절을 활용하여 성능 향상

   ```java
   @Query(value = "SELECT * FROM urls u WHERE u.click_count > :minClicks ORDER BY u.click_count DESC LIMIT 100", nativeQuery = true)
   List<Url> findTopUrlsByClickCount(@Param("minClicks") long minClicks);
   ```

3. **활성 URL 조회 쿼리**:
    - 복합 인덱스를 활용한 효율적인 조회 쿼리 설계

   ```java
   @Query("SELECT u FROM Url u WHERE u.shortCode = :shortCode AND (u.expiresAt IS NULL OR u.expiresAt > CURRENT_TIMESTAMP)")
   Optional<Url> findActiveByShortCode(@Param("shortCode") String shortCode);
   ```

Spring Data JPA는 내부적으로 Hibernate를 통해 Prepared Statement를 사용합니다. 이를 통해 반복적인 쿼리 실행 시 SQL 파싱 및 컴파일 단계를 건너뛰어 성능을 향상시켰습니다.

## 3. 결과

데이터베이스 최적화 전략 적용 후 다음과 같은 성과를 달성했습니다:

- **단축 URL 생성 응답 시간**: 79ms → 57ms (27.8% 감소)
- **인덱스 최적화 후 리다이렉트 응답 시간**: 7ms → 4ms (42.9% 감소)
- **데이터베이스 부하**: 90% 이상 감소
- **오류율**: 0.00204% → 0.00130% (36.3% 감소)

특히 인덱스 최적화는 캐시 미스 상황에서도 빠른 응답 시간을 보장하여 전체 시스템의 안정성을 크게 향상시켰습니다.

## 4. 한계점 및 향후 개선 방향

현재 데이터베이스 최적화 전략에는 다음과 같은 향후 개선 가능성이 있습니다:

**단일 데이터베이스의 한계**: 현재는 단일 데이터베이스 인스턴스를 사용하고 있어 확장성과 고가용성에 제한이 있습니다. 서비스가 더 성장한다면 읽기 전용 복제본 추가나 샤딩 같은 수평적 확장 전략을 고려해야 할 것입니다.

**복잡한 통계 쿼리 최적화**: 현재 일부 통계 관련 쿼리는 최적화 여지가 남아있습니다. 대시보드용 복잡한 집계 쿼리는 미리 계산된 통계 테이블을 활용하거나 전용 분석 데이터베이스로 분리하는 것이 효과적일 수 있습니다.

데이터베이스 최적화 전략은 캐싱 전략과 함께 스냅링크의 성능을 크게 향상시켰으며, 특히 캐시 미스 상황에서도 안정적인 성능을 보장하는 중요한 역할을 했습니다.