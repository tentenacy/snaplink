# 스냅링크

스냅링크는 긴 URL을 7자리 짧은 코드로 변환하고 빠른 리다이렉트를 제공하는 고성능 URL 단축 서비스입니다. Redis 캐싱을 통한 데이터베이스 부하 감소 및 응답 시간 최적화에 중점을 둔 프로젝트로, 읽기:쓰기 비율이 100:1인 워크로드 특성을 활용해 최적의 성능을 구현했습니다.

## 프로젝트 핵심 성과

| 메트릭 | 최적화 전 | 최적화 후 | 개선율 |
| --- | --- | --- | --- |
| 리다이렉트 응답시간 | 46ms | 4ms | **91.3%** 감소 |
| TPS (초당 트랜잭션) | 771.9 | 1,003.5 | **30.0%** 증가 |
| 데이터베이스 부하 | 100% | <10% | **90%+** 감소 |
| 오류율 | 0.00492% | 0.00130% | **73.6%** 감소 |

## 주요 기능

- **URL 단축**: 긴 URL을 7자리 짧은 코드로 변환 (Base62 인코딩)
- **커스텀 코드**: 사용자 지정 단축 코드 지원
- **유효기간 설정**: URL 만료일 설정 기능
- **클릭 통계**: 단축 URL 사용 현황 추적 및 분석 (비동기 처리)
- **고성능 캐싱**: Redis를 활용한 95% 이상의 캐시 히트율 달성

## 기술 스택

### Backend Framework

- Java 17 (LTS)
- Spring Boot 3.5.4
- Spring Web (REST API)
- Spring Data JPA (ORM)
- Spring Boot Cache, Spring Data Redis (캐싱)
- Spring Boot Actuator (모니터링)
- Maven (빌드 도구)

### 데이터베이스 & 캐싱

- MySQL 8.0 (영구 저장소)
- Redis 7.0 (고성능 캐싱)
- HikariCP (커넥션 풀 최적화)
- B-tree 인덱스 (단축 코드 기반 빠른 조회)

### 최적화 기법

- Custom Base62 Encoder (URL 인코딩, 충돌 최소화)
- Redis Pipeline (다중 명령어 일괄 처리)
- Database Prepared Statement (SQL 파싱 오버헤드 제거)

### 테스팅 & 성능 측정

- JUnit 5 & Spring Boot Test (단위/통합 테스트)
- Testcontainers (MySQL, Redis 테스트 환경)
- Apache JMeter (부하 테스트)
- Mockito (Mock 테스트)

### 배포 & 인프라

- Docker & Docker Compose (컨테이너화)
- GitHub Actions (CI/CD 파이프라인)
- AWS EC2 (프리티어 활용)

### 모니터링 & 로깅

- Micrometer (메트릭 수집)
- Prometheus (시계열 데이터 저장)
- Grafana (모니터링 대시보드)
- Logback (구조화된 로깅)

## 시스템 아키텍처

### 앱 아키텍처

스냅링크는 다음과 같은 3계층 아키텍처로 구성되어 있습니다:

1. **Web Layer**: REST API 컨트롤러, 요청 검증, 예외 처리
2. **Service Layer**: 비즈니스 로직, 트랜잭션 관리, 캐싱 전략
3. **Data Layer**: 데이터베이스 접근, 영속성 관리

![SnapLink Architecture](/docs/images/app-architecture-diagram.png)

### 인프라 및 배포 아키텍처

스냅링크 프로젝트는 자동화된 CI/CD 파이프라인과 컨테이너화된 배포 환경을 통해 안정적이고 확장 가능한 인프라를 구축했으며, 다음과 같은 요소로 구성되어 있습니다.


1. **애플리케이션 서버**: Spring Boot 애플리케이션 (컨테이너화)
2. **웹 서버/프록시**: Nginx (HTTPS 종단, 요청 라우팅)
3. **데이터베이스**: MySQL (영구 데이터 저장)
4. **캐시 서버**: Redis (고성능 인메모리 캐싱)
5. **모니터링 스택**: Prometheus(메트릭 수집), Grafana(대시보드)
6. **인증서 관리**: Certbot (SSL 인증서 자동 갱신)

![SnapLink Architecture](/docs/images/ci-cd-architecture-diagram.png)

이 아키텍처는 AWS 프리티어 환경에서도 효율적으로 운영되도록 설계되었으며, 컨테이너 기반 접근 방식을 통해 확장성과 이식성을 확보했습니다. GitHub Actions와 Docker를 활용한 CI/CD 파이프라인은 코드 변경사항을 신속하게 프로덕션에 반영하면서도 품질을 보장합니다.

## 성능 최적화 전략

### 1\. Redis 다층 캐싱 전략

- **접근 패턴 분석**: 읽기:쓰기 비율 100:1 특성 활용
- **TTL 정책**: 접근 빈도에 따른 동적 TTL 조정
- **캐시 일관성**: Write-Through 패턴으로 데이터 일관성 보장
- **캐시 워밍업**: 핫 데이터 사전 로드로 초기 캐시 히트율 향상

### 2\. 데이터베이스 최적화

- **인덱스 설계**: 단축 코드 기반 B-tree 인덱스 적용
- **커넥션 풀 튜닝**: HikariCP 최적 설정으로 연결 관리 효율화
- **Prepared Statement**: SQL 파싱 오버헤드 제거

### 3\. 비동기 처리

- **클릭 통계**: 핵심 흐름에 영향 없는 비동기 통계 처리
- **@Async 어노테이션**: Spring의 비동기 처리 기능 활용

## 성능 테스트 결과

### 테스트 환경 및 조건

성능 테스트는 Apache JMeter를 사용하여 다음과 같은 조건에서 수행되었습니다:

- **하드웨어**: i7-8700 CPU, 32GB RAM
- **데이터베이스**: AWS RDS MariaDB
    - 성능 차이를 현실적으로 측정
- **테스트 시나리오**:
    - URL 리다이렉트 테스트: 100 스레드, 10초 램프업, 100회 반복 (10,000 요청)
    - URL 생성 테스트: 20 스레드, 5초 램프업, 10회 반복 (200 요청)
    - 통계 조회 테스트: 10 스레드, 2초 램프업, 5회 반복 (50 요청)
    - 메트릭 조회 테스트: 5 스레드, 1초 램프업, 5회 반복 (25 요청)
    - 부하 테스트: 500 스레드, 60초 램프업, 120초 지속 (500 요청)
- **최적화 단계**:
    - 단계 1: 기본 구현 (캐싱 X, 튜닝 X)
    - 단계 2: Redis 캐싱 추가 (캐싱 O, 튜닝 X)
    - 단계 3: HikariCP 튜닝 (캐싱 O, 튜닝 O)
    - 단계 4: 인덱스 최적화 (최종)

### 리다이렉트 요청 (주요 사용 케이스)

| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | TPS | 오류율 |
| --- | --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 46ms | 336ms | 771.9 | 0% |
| 캐싱 O, 튜닝 X | 8ms | 397ms | 1001.9 | 0% |
| 캐싱 O, 튜닝 O | 7ms | 383ms | 1001.0 | 0% |
| 최종 (+ 인덱스 최적화) | 4ms | 407ms | 1003.5 | 0% |

<details>
<summary>각 API 엔드포인트별 성능 테스트 결과</summary>

#### URL 생성 API
| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | 오류율 |
| --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 79ms | 552ms | 0.03% |
| 캐싱 O, 튜닝 X | 70ms | 754ms | 0.045% |
| 캐싱 O, 튜닝 O | 70ms | 597ms | 0.06% |
| 최종 (+ 인덱스 최적화) | 57ms | 587ms | 0.04% |

#### URL 통계 조회 API
| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | 오류율 |
| --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 69ms | 543ms | 0% |
| 캐싱 O, 튜닝 X | 83ms | 639ms | 0% |
| 캐싱 O, 튜닝 O | 76ms | 546ms | 0% |
| 최종 (+ 인덱스 최적화) | 64ms | 537ms | 0% |

#### 메트릭 조회 API
| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | 오류율 |
| --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 49ms | 320ms | 0% |
| 캐싱 O, 튜닝 X | 60ms | 391ms | 0% |
| 캐싱 O, 튜닝 O | 59ms | 351ms | 0% |
| 최종 (+ 인덱스 최적화) | 63ms | 307ms | 0% |

#### 리다이렉트 부하 테스트
| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | 오류율 |
| --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 17ms | 329ms | 0.094% |
| 캐싱 O, 튜닝 X | 5ms | 381ms | 0.028% |
| 캐싱 O, 튜닝 O | 5ms | 389ms | 0.02% |
| 최종 (+ 인덱스 최적화) | 4ms | 393ms | 0.012% |

#### 전체 테스트 결과 (모든 API 엔드포인트)
| 최적화 단계 | 평균 응답시간 | 최대 응답시간 | 오류율 |
| --- | --- | --- | --- |
| 캐싱 X, 튜닝 X | 46ms | 552ms | 0.00492% |
| 캐싱 O, 튜닝 X | 10ms | 754ms | 0.00213% |
| 캐싱 O, 튜닝 O | 8ms | 597ms | 0.00204% |
| 최종 (+ 인덱스 최적화) | 6ms | 587ms | 0.00130% |
</details>

## 기술적 도전과 해결 방법

### 도전 1: 대용량 트래픽 처리

**문제**: 초당 1,000건 이상의 요청을 5ms 이내에 처리해야 함

**해결**: 다층 캐싱 전략 구현

- Redis의 in-memory 특성을 활용한 빠른 응답 시간 달성
- 핫 데이터 분석 및 우선 캐싱으로 히트율 최적화
- Redis Pipeline으로 네트워크 왕복 시간 최소화
- 읽기 작업 중심 워크로드에 최적화된 캐시 정책 설계

**결과**: 응답 시간 91.3% 감소 (46ms → 4ms)

### 도전 2: 효율적인 단축 코드 생성

**문제**: 7자리 코드로 중복 없이 수십억 개의 URL을 지원해야 함

**해결**: 최적화된 Base62 인코딩 알고리즘 구현

- Base62(0-9, a-z, A-Z) 인코딩으로 62^7 (약 3.5조) 개의 고유 코드 공간 확보
- 시스템 타임스탬프와 원자적 시퀀스를 조합하여 중복 방지
- 충돌 발생 시 효율적인 재시도 메커니즘 구현
- MySQL 유니크 제약조건으로 최종 안전망 구축

**결과**: 단축 코드 생성 응답 시간 27.8% 감소 (79ms → 57ms)

### 도전 3: AWS 프리티어 환경에서 최적 성능 달성

**문제**: 제한된 리소스(t2.micro)에서 고성능 서비스 운영

**해결**: 리소스 효율적인 아키텍처 설계

- 비용 효율적인 다중 계층 캐싱으로 데이터베이스 부하 최소화
- 비동기 처리로 핵심 흐름과 부가 기능 분리
- JVM 및 컨테이너 메모리 설정 최적화
- HikariCP 커넥션 풀 튜닝으로 제한된 리소스 효율적 활용

**결과**: AWS 프리티어 환경에서 초당 1,000+ 트랜잭션 처리 달성

## API 문서

API 문서는 Swagger UI를 통해 제공됩니다. [여기](https://snlink.xyz/swagger-ui.html)에서 확인할 수 있습니다.

주요 API 엔드포인트:

| 엔드포인트                | 메서드 | 설명  |
|----------------------| --- | --- |
| /{shortCode}         | GET | 단축 URL 리다이렉트 |
| /api/v1/urls            | POST | URL 단축 생성 |
| /api/v1/urls/{shortCode} | GET | URL 정보 조회 |
| /api/v1/urls/{shortCode}/stats | GET | 클릭 통계 조회 |
| /api/v1/metrics         | GET | 시스템 메트릭 조회 |

## 설치 및 실행 방법

### 로컬 개발 환경

1. 저장소 클론

```
git clone https://github.com/yourusername/snaplink.git
cd snaplink
```
2. Docker Compose로 애플리케이션 실행

```
docker-compose -f ./docker/docker-compose.yml up -d
```

## 성능 모니터링 지표

위 지표는 Prometheus와 Spring Boot Actuator를 통해 수집되었으며, 전체 시스템의 성능과 안정성을 보여줍니다. 특히 리다이렉트 API는 최적화를 통해 1,000+ TPS의 높은 성능을 달성했으며, 시스템 전체적으로는 350 TPS의 안정적인 처리량을 유지하고 있습니다.

최종 최적화 후 측정된 주요 성능 지표:

- 캐시 히트율: 99.94%
- 평균 응답 시간: 3.66ms
- 95% 응답 시간: 0.78ms
- 99% 응답 시간: 1.11ms
- TPS (초당 트랜잭션 수): 350
- 총 요청 수: 21,000
- 에러율: 0.1333%
- DB 쿼리 수: 43,972
- 활성 URL 수: 1,386

## 향후 개선 계획

1. **수평적 확장성 강화**
    - Redis Cluster 도입으로 캐시 확장성 향상
    - 애플리케이션 서버 로드 밸런싱 구현
2. **보안 강화**
    - Rate Limiting 구현으로 DoS 공격 방어
    - API 키 인증 체계 도입
3. **기능 확장**
    - 사용자 계정 시스템 도입
    - 상세 분석 대시보드 개발
    - QR 코드 생성 기능 추가

## 라이선스

MIT License

* * *

© 2025 SnapLink URL Shortening Service